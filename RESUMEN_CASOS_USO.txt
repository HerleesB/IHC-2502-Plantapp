===================================================================================
  ğŸ“± JARDÃN INTELIGENTE - RESUMEN DE CASOS DE USO PRINCIPALES
===================================================================================

Este documento explica las funcionalidades principales de la aplicaciÃ³n,
mostrando el flujo completo desde el frontend hasta la base de datos.

===================================================================================


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ“¸ CASO 1: CAPTURAR Y DIAGNOSTICAR FOTO                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ“ QUÃ‰ HACE:
   El usuario toma una foto de una planta y la app le dice quÃ© enfermedad tiene
   y cÃ³mo cuidarla.

ğŸ“± FRONTEND:
   Archivo: CaptureScreen.kt
   FunciÃ³n: validateAndDiagnose(imageUri)
   
   1. Usuario hace click en "Capturar" o "GalerÃ­a"
   2. Selecciona/toma foto de la planta
   3. La imagen se envÃ­a al backend

ğŸ BACKEND:
   Endpoint: POST /api/diagnosis/capture-guidance
   Archivo: backend/app/routes/diagnosis.py
   
   1. Valida calidad de la foto (iluminaciÃ³n, enfoque)
   2. Si calidad >= 40%, hace diagnÃ³stico con IA
   3. Guarda imagen en servidor
   4. Devuelve: recomendaciones + diagnÃ³stico

ğŸ—„ï¸  BASE DE DATOS:
   Tabla: diagnoses
   
   INSERT INTO diagnoses (
       user_id, image_url, diagnosis_text,
       disease_name, confidence, severity, recommendations
   )
   
   RelaciÃ³n: diagnoses.user_id â†’ users.id

ğŸ’¡ RESULTADO:
   Usuario ve: "Tu planta tiene manchas foliares. Confianza: 85%"
   + Recomendaciones de tratamiento


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸŒ± CASO 2: AGREGAR PLANTA AL JARDÃN                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ“ QUÃ‰ HACE:
   DespuÃ©s de diagnosticar, el usuario guarda la planta en "Mi JardÃ­n" para
   hacerle seguimiento.

ğŸ“± FRONTEND:
   Archivo: AddPlantScreen.kt
   FunciÃ³n: addPlantFromDiagnosis(name, species, diagnosisId)
   
   1. Usuario ve resultado del diagnÃ³stico
   2. Click en "Agregar a Mi JardÃ­n"
   3. Ingresa nombre y tipo de planta
   4. Confirma

ğŸ BACKEND:
   Endpoint: POST /api/plants
   Archivo: backend/app/routes/plants.py
   
   1. Crea registro de planta
   2. Vincula con el diagnÃ³stico
   3. Calcula health_score inicial
   4. Otorga XP al usuario

ğŸ—„ï¸  BASE DE DATOS:
   Tabla: plants
   
   INSERT INTO plants (
       user_id, name, species, image_url,
       status, health_score, location
   )
   
   Relaciones: 
   - plants.user_id â†’ users.id
   - Puede referenciar diagnoses.id

ğŸ’¡ RESULTADO:
   La planta aparece en "Mi JardÃ­n" con su foto, estado de salud y nombre


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ’¬ CASO 3: PUBLICAR EN COMUNIDAD                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ“ QUÃ‰ HACE:
   El usuario comparte una consulta sobre su planta para que otros usuarios
   de la comunidad le ayuden.

ğŸ“± FRONTEND:
   Archivo: CommunityShareScreen.kt
   FunciÃ³n: publishPost(image, description, plantName, symptoms)
   
   1. Usuario navega a Comunidad
   2. Click en "Publicar"
   3. Sube foto de la planta
   4. Completa formulario:
      - Â¿QuÃ© problema tiene?
      - Nombre de la planta
      - SÃ­ntomas que observa
      - â˜‘ï¸ Publicar como anÃ³nimo
   5. Click "Publicar"

ğŸ BACKEND:
   Endpoint: POST /api/community/posts/with-image
   Archivo: backend/app/routes/community.py
   
   1. Valida que el usuario existe
   2. Modera contenido (detecta spam/ofensivo)
   3. Guarda imagen en /uploads/community/
   4. Crea diagnÃ³stico temporal
   5. Crea publicaciÃ³n en comunidad

ğŸ—„ï¸  BASE DE DATOS:
   Tablas: community_posts, diagnoses
   
   -- Paso 1: DiagnÃ³stico temporal
   INSERT INTO diagnoses (...)
   
   -- Paso 2: PublicaciÃ³n
   INSERT INTO community_posts (
       diagnosis_id, user_id, is_anonymous,
       description, plant_name, symptoms, image_url
   )
   
   Relaciones:
   - community_posts.diagnosis_id â†’ diagnoses.id
   - community_posts.user_id â†’ users.id

ğŸ’¡ RESULTADO:
   La publicaciÃ³n aparece en el feed de la comunidad con foto y descripciÃ³n


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â¤ï¸ CASO 4: DAR LIKE A PUBLICACIÃ“N                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ“ QUÃ‰ HACE:
   El usuario da "me gusta" a una publicaciÃ³n de la comunidad.
   Solo puede dar 1 like por publicaciÃ³n.

ğŸ“± FRONTEND:
   Archivo: CommunityScreen.kt
   FunciÃ³n: toggleLike(postId, userId)
   
   1. Usuario ve publicaciones
   2. Click en corazÃ³n â¤ï¸
   3. Si ya dio like â†’ se quita
   4. Si no ha dado like â†’ se agrega

ğŸ BACKEND:
   Endpoint: POST /api/community/posts/{post_id}/like
   Archivo: backend/app/routes/community.py
   
   1. Busca si ya existe like de este usuario en este post
   2. Si existe: elimina like, decrementa contador
   3. Si no existe: crea like, incrementa contador
   4. Retorna: {liked: true/false, total_likes: 15}

ğŸ—„ï¸  BASE DE DATOS:
   Tablas: post_likes, community_posts
   
   -- Verificar si existe
   SELECT * FROM post_likes 
   WHERE post_id = ? AND user_id = ?
   
   -- Si no existe, agregar:
   INSERT INTO post_likes (post_id, user_id)
   UPDATE community_posts SET likes = likes + 1
   
   -- Si existe, quitar:
   DELETE FROM post_likes WHERE ...
   UPDATE community_posts SET likes = likes - 1
   
   Constraint: UNIQUE(post_id, user_id) â† previene likes duplicados
   
   Relaciones:
   - post_likes.post_id â†’ community_posts.id
   - post_likes.user_id â†’ users.id

ğŸ’¡ RESULTADO:
   El corazÃ³n se llena/vacÃ­a y el contador cambia: 14 â¤ï¸ â†’ 15 â¤ï¸


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ—‘ï¸ CASO 5: ELIMINAR PLANTA                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ“ QUÃ‰ HACE:
   El usuario elimina una planta de su jardÃ­n junto con todo su historial.

ğŸ“± FRONTEND:
   Archivo: PlantDetailScreen.kt
   FunciÃ³n: deletePlant(plantId, userId)
   
   1. Usuario abre detalle de una planta
   2. Click en Ã­cono de eliminar ğŸ—‘ï¸
   3. Aparece advertencia:
      "Esto eliminarÃ¡ permanentemente:
       â€¢ La planta
       â€¢ Todos sus diagnÃ³sticos
       â€¢ Todo su historial"
   4. Usuario confirma "Eliminar"

ğŸ BACKEND:
   Endpoint: DELETE /api/plants/{plant_id}
   Archivo: backend/app/routes/plants.py
   
   1. Verifica que la planta existe
   2. Verifica que pertenece al usuario
   3. Cuenta diagnÃ³sticos asociados
   4. Elimina todos los diagnÃ³sticos
   5. Elimina la planta
   6. Retorna: "Planta 'Rosa' eliminada (3 diagnÃ³sticos)"

ğŸ—„ï¸  BASE DE DATOS:
   Tablas: plants, diagnoses
   
   -- Paso 1: Eliminar diagnÃ³sticos
   DELETE FROM diagnoses WHERE plant_id = ?
   
   -- Paso 2: Eliminar planta
   DELETE FROM plants WHERE id = ? AND user_id = ?
   
   Relaciones:
   - plants.id â† diagnoses.plant_id (CASCADE)

ğŸ’¡ RESULTADO:
   La planta desaparece de "Mi JardÃ­n" junto con todo su historial


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ”„ CASO 6: ACTUALIZAR PLANTA CON NUEVO DIAGNÃ“STICO                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ“ QUÃ‰ HACE:
   El usuario hace un nuevo diagnÃ³stico a una planta existente y actualiza
   su foto y estado de salud.

ğŸ“± FRONTEND:
   Archivo: PlantDetailScreen.kt
   FunciÃ³n: updatePlantWithDiagnosis(plantId, imageUri)
   
   1. Usuario abre detalle de planta
   2. Click en "Diagnosticar"
   3. Toma/selecciona nueva foto
   4. Backend analiza y actualiza

ğŸ BACKEND:
   Endpoint: PUT /api/plants/{plant_id}/update-with-diagnosis
   Archivo: backend/app/routes/plants.py
   
   1. Verifica que planta existe
   2. Guarda nueva imagen
   3. Hace diagnÃ³stico con IA
   4. Crea nuevo registro en diagnoses
   5. Actualiza planta:
      - Imagen nueva
      - Estado (healthy/moderate/critical)
      - Health score (0-100)
      - Fecha de Ãºltimo diagnÃ³stico

ğŸ—„ï¸  BASE DE DATOS:
   Tablas: plants, diagnoses
   
   -- Paso 1: Nuevo diagnÃ³stico
   INSERT INTO diagnoses (
       plant_id, user_id, image_url,
       diagnosis_text, disease_name, severity
   )
   
   -- Paso 2: Actualizar planta
   UPDATE plants SET
       image_url = ?,
       status = ?,
       health_score = ?,
       last_diagnosis = CURRENT_TIMESTAMP
   WHERE id = ?
   
   Relaciones:
   - diagnoses.plant_id â†’ plants.id

ğŸ’¡ RESULTADO:
   La planta muestra su nueva foto y estado actualizado
   El historial de diagnÃ³sticos se conserva


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ’§ CASO 7: REGISTRAR RIEGO                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ“ QUÃ‰ HACE:
   El usuario marca que regÃ³ una planta para llevar control de cuidados.

ğŸ“± FRONTEND:
   Archivo: MyGardenScreen.kt
   FunciÃ³n: waterPlant(plantId)
   
   1. Usuario ve lista de plantas
   2. Click en Ã­cono de gota ğŸ’§
   3. Planta se marca como "Regada hace X minutos"

ğŸ BACKEND:
   Endpoint: PUT /api/plants/{plant_id}/water
   Archivo: backend/app/routes/plants.py
   
   1. Actualiza fecha de Ãºltimo riego
   2. Otorga XP al usuario (+10)
   3. Actualiza racha de dÃ­as activos
   4. Puede desbloquear logros

ğŸ—„ï¸  BASE DE DATOS:
   Tablas: plants, users
   
   -- Actualizar riego
   UPDATE plants 
   SET last_watered = CURRENT_TIMESTAMP 
   WHERE id = ?
   
   -- Actualizar gamificaciÃ³n
   UPDATE users 
   SET xp = xp + 10,
       last_activity = CURRENT_TIMESTAMP
   WHERE id = ?
   
   Relaciones:
   - plants.user_id â†’ users.id

ğŸ’¡ RESULTADO:
   Planta muestra "Regada hace 2 minutos"
   Usuario gana +10 XP


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ† CASO 8: VER LOGROS Y MISIONES                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ“ QUÃ‰ HACE:
   El usuario ve su progreso de logros desbloqueados y misiones activas
   (diarias/semanales).

ğŸ“± FRONTEND:
   Archivo: GamificationScreen.kt
   FunciÃ³n: loadAchievements() + loadMissions()
   
   1. Usuario navega a "Logros y Misiones"
   2. Se cargan automÃ¡ticamente:
      - Nivel y barra de XP
      - Logros desbloqueados/bloqueados
      - Misiones diarias con progreso
      - Misiones semanales

ğŸ BACKEND:
   Endpoint: GET /api/gamification/achievements/{user_id}
            GET /api/gamification/missions/{user_id}
   Archivo: backend/app/routes/gamification.py
   
   1. Obtiene todos los logros disponibles
   2. Cruza con user_achievements (cuÃ¡les tiene el usuario)
   3. Calcula progreso de cada uno
   4. Para misiones: filtra por frecuencia y fecha
   5. Retorna logros ordenados + misiones activas

ğŸ—„ï¸  BASE DE DATOS:
   Tablas: achievements, user_achievements, missions, user_missions, users
   
   -- Logros del usuario
   SELECT a.*, ua.progress, ua.unlocked_at
   FROM achievements a
   LEFT JOIN user_achievements ua 
       ON a.id = ua.achievement_id 
       AND ua.user_id = ?
   
   -- Misiones activas
   SELECT m.*, um.progress, um.completed
   FROM missions m
   LEFT JOIN user_missions um 
       ON m.id = um.mission_id 
       AND um.user_id = ?
   WHERE m.frequency IN ('daily', 'weekly')
       AND um.expires_at > CURRENT_TIMESTAMP
   
   Relaciones:
   - user_achievements.user_id â†’ users.id
   - user_achievements.achievement_id â†’ achievements.id
   - user_missions.user_id â†’ users.id
   - user_missions.mission_id â†’ missions.id

ğŸ’¡ RESULTADO:
   Usuario ve:
   - "Nivel 5 | 450/600 XP"
   - Logros: ğŸ† "Jardinero Novato" âœ… | "Maestro de Plantas" ğŸ”’
   - Misiones diarias: "Riega 3 plantas" (2/3) 80 XP


===================================================================================
  ğŸ“Š RESUMEN DE TABLAS PRINCIPALES
===================================================================================

users â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚
              â”œâ”€â†’ plants â”€â”€â”€â†’ diagnoses
              â”‚                    â”‚
              â”‚                    â†“
              â”œâ”€â†’ community_posts â†â”˜
              â”‚         â”‚
              â”‚         â”œâ”€â†’ post_likes
              â”‚         â””â”€â†’ comments
              â”‚
              â”œâ”€â†’ user_achievements â†â”€ achievements
              â””â”€â†’ user_missions â†â”€â”€â”€â”€â”€â”€ missions


===================================================================================
  ğŸ¯ FLUJO GENERAL DE DATOS
===================================================================================

1. FRONTEND (Kotlin/Android)
   â””â”€ Usuario interactÃºa con UI (click, input)
   â””â”€ UI llama a ViewModel
   
2. VIEWMODEL
   â””â”€ Maneja lÃ³gica de negocio
   â””â”€ Llama a Repository o directamente a ApiService
   
3. APISERVICE (Retrofit)
   â””â”€ Hace request HTTP al backend
   â””â”€ POST, GET, PUT, DELETE
   
4. BACKEND (Python/FastAPI)
   â””â”€ Recibe request
   â””â”€ Valida datos
   â””â”€ Procesa lÃ³gica de negocio
   â””â”€ Hace queries a base de datos
   
5. BASE DE DATOS (SQLite)
   â””â”€ Ejecuta SQL (INSERT, UPDATE, SELECT, DELETE)
   â””â”€ Retorna resultados
   
6. BACKEND â†’ FRONTEND
   â””â”€ Backend retorna JSON
   â””â”€ Retrofit convierte JSON â†’ Objetos Kotlin
   â””â”€ ViewModel actualiza estado
   â””â”€ UI se re-renderiza automÃ¡ticamente


===================================================================================
  ğŸ’¡ CONSEJOS PARA TRABAJAR CON EL CÃ“DIGO
===================================================================================

ğŸ“± Si vas a modificar el FRONTEND:
   1. Busca el archivo Screen.kt de la pantalla
   2. Encuentra el ViewModel correspondiente
   3. Busca la funciÃ³n que llama a ApiService
   4. Modifica la lÃ³gica

ğŸ Si vas a modificar el BACKEND:
   1. Busca el archivo en routes/ correspondiente
   2. Encuentra la funciÃ³n del endpoint
   3. Modifica la lÃ³gica
   4. Actualiza modelos si cambias estructura de datos

ğŸ—„ï¸  Si vas a modificar la BASE DE DATOS:
   1. Crea script de migraciÃ³n
   2. Actualiza modelos en backend/app/models/database.py
   3. Actualiza ApiModels.kt en frontend si cambia estructura
   4. Prueba que frontend y backend siguen funcionando


===================================================================================
  âœ… FIN DEL RESUMEN
===================================================================================
